/*Программа для Практической работы 10.4 */
#include <stdio.h>      //Подключение библиотек ввода-вывода
#include <stdint.h>     //Подключение библиотек для типов uint
#include <stdlib.h>     //Подключение библиотек, содержащих функцию system("cls") для очистки экрана

//Определения макросов, применяемых в программе
#define FIB_COUNT    Calculation(n)          //Макрос FIB_COUNT заменяет вызов процедуры Calculation(n)
#define GAMING       Game()                  //Макрос GAMING заменяет вызов процедуры Game()
#define RENDERING    View(Rendered_Chart)    //Макрос RENDERING заменяет вызов процедуры View(Rendered_Chart)
#define END          return 0                //Макрос END заменяет оператор return 0

#define GAME_1  { {"qwert"},{"rtyui"},{"trewq"},{"iuytr"},{"yuiop"} } //Набор символов, содержащихся в массиве  Data_Chart, для варианта GAME_1
#define GAME_2  { {"asdfg"},{"gfdsa"},{"fghjk"},{"kjhgf"},{"ghjkl"} } //Набор символов, содержащихся в массиве  Data_Chart, для варианта GAME_2
#define GAME_3  { {"zxcvb"},{"bvcxz"},{"vbnmn"},{"mnbvc"},{"bvcxz"} } //Набор символов, содержащихся в массиве  Data_Chart, для варианта GAME_3

//Условия, определяющие выборочную компиляцию участков кода
#define FIBONACHHI 0 //Определение макроса FIBONACHHI как 0
#define GAME       1 //Определение макроса GAME как 1

#define MODE   GAME //MODE является определителем условной компияляции

//Определения глобальных переменных и прототипов функций

           #if MODE==FIBONACHHI  //Если выбран режим компиляции под вычислении функции Фибоначчи
//Рекурсивная функция, вычисляющая один член ряда Фибоначчи для заданной позиции n
uint16_t Calculation(uint8_t n);

           #else                //Если выбран режим компиляции под "игру"
//Объявление глобальных переменных
//Исходный двумерный массив, содержащий значения букв в коде ASCII. Недоступен для просмотра пользователем.
 char Data_Chart[5][5]=GAME_1;
//Одномерный массив переменных, каждая из которых, в свою очередь,
//является "массивом" битовых значений (флагов), хранящих информацию об открытии пользователем элементов первого массива
//Изначально все из них равны нулю
uint8_t Flag_Array[5]={0, 0, 0, 0, 0};
//Двумерный массив, выводимый на экран,
//куда помещаются отгаданные пользователем символы
char Rendered_Chart[5][5]={
{0, 0, 0, 0, 0},
{0, 0, 0, 0, 0},
{0, 0, 0, 0, 0},
{0, 0, 0, 0, 0},
{0, 0, 0, 0, 0}
                          };
//Прототипы процедур
void View(char Chart[][5]);
uint8_t Game(void);
           #endif

//Главная функция
int main()
{

        #if MODE==FIBONACHHI  //Если выбран режим компиляции под вычислении функции Фибоначчи
 uint16_t fib_num=0;              //Переменная для хранения вычисленного значения
 uint8_t n=0;                     //Переменная для хранения текущей позиции
 puts("Fibonachhi numbers:");     //Вывод заголовка "Числа Фибоначчи:"

 while(fib_num<2584)              //Цикл, пока вычисленное значение будет менее 2584
 {
  fib_num=FIB_COUNT;              //Вычисляется значение, соответствующие текущей позиции
  printf("Fib_num(%d)=", n);      //Вывод номера позиции в скобках
  printf("%d\n", fib_num);        //Вывод текущего вычисленного значения
  n++;                            //Инкремент позиции
 }
          #else  //Если выбран режим компиляции под "игру"
 RENDERING; //Выводим массив на экран. Изначально он будет пуст.
 GAMING;               //Вызываем процедуру, в которой происходит игра
          #endif  //Конец зоны условной компиляции

 END;//Окончание программ
}

              #if MODE==FIBONACHHI //Если выбран режим компиляции под вычислении функции Фибоначчи
//Рекурсивная функция, вычисляющая один член ряда Фибоначчи для заданной позиции n
uint16_t Calculation(uint8_t n)
{
 uint16_t temp;     //Переменная для хранения возвращаемого значения при вычислении
 if((n==0)||(n==1)) //Если n равно 0 или 1
 return n;          //Возвращается 0 или 1 соответственно
                    //Если не равно ни 0, ни 1, производится расчёт по формуле Фибоначчи с использованием рекурсии
 temp=Calculation(n-1)+Calculation(n-2);
 return temp;       //Возврат вычисленного значения
}
            #else   //Если выбран режим компиляции под "игру"
            //Процедура отображения заданного двумерного массива и выравнивания отображаемых символов
void View(char Chart[][5])
{
 for(uint8_t i=0; i<5; i++)     //Цикл для перебора строк
 {
  for(uint8_t j=0; j<5; j++)    //Цикл для перебора элементов в каждой строке
  {
   if(Chart[i][j]==0)           //Если данный элемент "пуст"
    printf("| ");               //Вывести пробел с разделительной чертой
   else
    printf("|%c", Chart[i][j]); //Если данный элемент не "пуст", вывести символ и разделительную черту
  }
  puts("|");                    //Вывод разделительной черты в конце строки
 }
}

//Процедура, осуществляющая игровой процесс
uint8_t Game(void)
{
 char Letter;                  //Переменная, хранящая вводимые символы
 uint8_t sum=0;                //Переменная, хранящая количество отгаданных ячеек

 printf("Input any letter: "); //Строка "Введите любую букву:"
 scanf("%c", &Letter);         //Ввод буквы в той же строке
 system("cls");                //Вызов процедуры для очистки экрана от ранее введенных букв и ранее выведенного массива

 for(uint8_t i=0; i<5; i++)    //Цикл для перебора строк
 {
  for(uint8_t j=0; j<5; j++)   //Цикл для перебора элементов в каждой строке
  {
   //Проверка выполнения условия открытия каждой ячейки:
   //Если введенная буква совпадает со значением в соответствующей ячейке массива Data_Chart
   //или бит (флаг) в j-ом бите i-го элемента массива Flag_Array установлен в 1
   if((Letter==Data_Chart[i][j])||(Flag_Array[i]&(1<<j)))
   {
    //Усановить в с помощью поразрядной операции ИЛИ и битовой маски в 1 j-ый бит i-го элемента массива Flag_Array
    //Таким образом, будет сохранена информация о ранее отгаданных ячейках
    Flag_Array[i]|=(1<<j);
    //Записать отгаданный символ из ячейки Data_Chart в соответствующую ячейку  Rendered_Chart
    Rendered_Chart[i][j]=Data_Chart[i][j];
    //Инкрементировать количество отгаданных ячеек
    //По окончанию цикла это значение будет равно общему количеству отгаданных ячеек
    sum++;
   }
  }
 }

 RENDERING; //Вывести на экран содержимое массива с отгаданными ячейками

 if(sum==25)          //Если количество отгаданных ячеек равно 25 (т.е. был отгаданы все ячейки)
 {
   puts("GAME OVER"); //Вывести сообщение о завершении игры
   return sum;        //Вернуть количество отгаданных ячеек c целью завершения процедуры
 }
 else                 //Если количество отгаданных ячеек не достигло 25,
 return Game();       //произвести повторный вызов функции Game, т.е. рекурсию.
}

            #endif  //Конец зоны условной компиляции
